Алгоритм бинарного поиска - это алгоритм поиска элемента в отсортированном массиве. Он работает путем разделения массива на две части и последующего сравнения 
искомого элемента с элементом в середине массива.  
Если искомый элемент меньше, чем элемент в середине массива, поиск продолжается только в левой части массива.  
Если искомый элемент больше, чем элемент в середине массива, поиск продолжается только в правой части массива.  
Этот процесс повторяется, пока искомый элемент не будет найден или пока не будет установлено, что элемента в массиве нет.

Теоретически, алгоритм бинарного поиска имеет сложность O(log n), что означает, что время поиска будет увеличиваться не пропорционально количеству элементов в массиве, 
а в зависимости от количества итераций цикла. Таким образом, бинарный поиск может быть эффективным алгоритмом для поиска элементов в больших отсортированных массивах.

Вот пример бинарного поиска на C++:

int binarySearch(int arr[], int left, int right, int x) {  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (arr[mid] == x) {  
            return mid;  
        }  
        else if (arr[mid] < x) {  
            left = mid + 1;  
        }  
        else {  
            right = mid - 1;  
        }  
    }  
    return -1;  
}  

Эта функция принимает отсортированный массив arr, левую и правую границы массива (начало и конец), и элемент, который нужно найти.  
Функция возвращает индекс элемента в массиве, если элемент найден, или -1, если элемент отсутствует.  

Пример использования функции:
int arr[] = {1, 3, 5, 7, 9};  
int n = sizeof(arr) / sizeof(arr[0]);  
int x = 5;  
int result = binarySearch(arr, 0, n - 1, x);  
if (result == -1) {  
    cout << "Element is not present in array" << endl;  
}  
else {  
    cout << "Element is present at index " << result << endl;  
}  

Этот код находит элемент со значением 5 в массиве и выводит его индекс, который равен 2.

Бинарный поиск может использоваться в различных задачах, например, в поиске определенного элемента в отсортированном массиве, в поиске в диапазоне значений,  
в поиске индекса первого или последнего вхождения элемента и т. д.  
binary_search - это стандартный алгоритм библиотеки STL C++, который позволяет производить бинарный поиск элемента в отсортированном диапазоне. Функция binary_search возвращает true, если элемент найден, и false в противном случае.

Вот синтаксис функции binary_search:  
template< class ForwardIt, class T >  
bool binary_search( ForwardIt first, ForwardIt last, const T& value );  

first и last - итераторы, задающие диапазон элементов для поиска.  
value - искомый элемент.  
Функция возвращает true, если элемент найден в диапазоне и false в противном случае.  

Вот пример использования функции binary_search:  
#include <iostream>
#include <algorithm>
#include <vector>

int main() {  
    std::vector<int> v{1, 3, 5, 7, 9};  
    int x = 5;  
    bool found = std::binary_search(v.begin(), v.end(), x);  
    if (found) {  
        std::cout << "Element " << x << " is found in the vector." << std::endl;  
    } else {  
        std::cout << "Element " << x << " is not found in the vector." << std::endl;  
    }  
    return 0;  
}  
upper_bound - это стандартный алгоритм библиотеки STL C++, который позволяет найти позицию первого элемента в отсортированном диапазоне, который больше или равен заданному значению.  
Функция upper_bound возвращает итератор на этот элемент.  

Вот синтаксис функции upper_bound:  
template< class ForwardIt, class T >  
ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T& value );  
first и last - итераторы, задающие диапазон элементов для поиска.
value - искомое значение.  
Функция возвращает итератор на первый элемент, который больше или равен value.  

Вот пример использования функции upper_bound:  
#include <iostream>  
#include <algorithm>  
#include <vector>  

int main() {  
    std::vector<int> v{1, 3, 3, 5, 7, 9};  
    int x = 3;  
    auto it = std::upper_bound(v.begin(), v.end(), x);  
    if (it != v.end()) {  
        std::cout << "The first element in the vector greater than " << x << " is " << *it << std::endl;  
    } else {  
        std::cout << "There is no element in the vector greater than " << x << std::endl;  
    }  
    return 0;  
}  
Функция upper_bound часто используется для решения задач на поиск элемента в отсортированном диапазоне, а также для вычисления длины диапазона, удовлетворяющего некоторому критерию.

По аналогии существует lower_bound смотрите документацию.